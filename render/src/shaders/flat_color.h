/**

This File is generated by shader_gen 
DO NOT EDIT

**/
#pragma once
#include <vector>
#include <GL/glew.h>
#include <GL/glut.h>
#include <iostream>
namespace render{
namespace shader{
namespace flat_color{

#define CheckGLError(){\
  while (true){\
    const GLenum err = glGetError();\
    if (GL_NO_ERROR == err)\
      break;\
    std::cout << __func__ << " line: "<< __LINE__ << " GL Error: " << GetGLErrorStr(err) << std::endl;\
  }\
}\

static constexpr char vertex_shader[166] = {0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x30,0x30,0x20,0x65,0x73,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xa,0x75,0x6e,0x69,0x66,0x6f,0x72,0x6d,0x20,0x6d,0x61,0x74,0x34,0x20,0x75,0x43,0x61,0x6d,0x65,0x72,0x61,0x3b,0xa,0x75,0x6e,0x69,0x66,0x6f,0x72,0x6d,0x20,0x6d,0x61,0x74,0x34,0x20,0x75,0x4d,0x6f,0x64,0x65,0x6c,0x4d,0x61,0x74,0x72,0x69,0x78,0x3b,0xa,0x69,0x6e,0x20,0x76,0x65,0x63,0x34,0x20,0x61,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x3b,0xa,0xa,0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x20,0x7b,0xa,0x20,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x75,0x43,0x61,0x6d,0x65,0x72,0x61,0x20,0x2a,0x20,0x75,0x4d,0x6f,0x64,0x65,0x6c,0x4d,0x61,0x74,0x72,0x69,0x78,0x20,0x2a,0x20,0x61,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x3b,0xa,0x7d,0xa,0x00}; 
static constexpr char fragment_shader[119] = {0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x33,0x30,0x30,0x20,0x65,0x73,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xa,0x70,0x72,0x65,0x63,0x69,0x73,0x69,0x6f,0x6e,0x20,0x6d,0x65,0x64,0x69,0x75,0x6d,0x70,0x20,0x66,0x6c,0x6f,0x61,0x74,0x3b,0xa,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,0x34,0x20,0x66,0x72,0x61,0x67,0x43,0x6f,0x6c,0x6f,0x72,0x3b,0xa,0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x20,0x7b,0xa,0x20,0x20,0x66,0x72,0x61,0x67,0x43,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x76,0x65,0x63,0x34,0x28,0x31,0x2c,0x31,0x2c,0x31,0x2c,0x31,0x29,0x3b,0xa,0x7d,0xa,0x00}; 

class flat_color {
public: 
  void compile(){
    GLuint vertexHandle = compileShader(vertex_shader,GL_VERTEX_SHADER);
    GLuint fragmentHandle = compileShader(fragment_shader,GL_FRAGMENT_SHADER);
    m_program = glCreateProgram();
    if(m_program == 0){
      std::cout << "Failed to compile shader" << std::endl; 
      return;
    }
    
    glAttachShader( m_program, vertexHandle ); 
    CheckGLError();
    glAttachShader( m_program, fragmentHandle ); 
    CheckGLError();
    glLinkProgram(m_program);
    CheckGLError();
    
    GLint status = GL_FALSE;
    GLint maxLength = 0;
	  glGetShaderiv(m_program, GL_INFO_LOG_LENGTH, &maxLength);
    CheckGLError();
	  std::vector<GLchar> errorLog(maxLength);

    glGetProgramiv(m_program, GL_LINK_STATUS, &status ); 
    CheckGLError();
    if( GL_FALSE == status ) {
      std::cerr << "Failed to link shader program!" << std::endl;
      GLint logLen; 
      glGetProgramiv(m_program, GL_INFO_LOG_LENGTH, &logLen); 
      CheckGLError();
      if( logLen > 0 ) { 
        std::string(logLen, ' ');
        GLsizei written;
        glGetProgramInfoLog(m_program, logLen, &written, &errorLog[0]); 
        CheckGLError();
        std::cerr << "Program log: " << std::endl << &errorLog;
      } 
    }
    enable();
    bind();
    disable();
  }
  
  void enable(){
    glUseProgram(m_program);
    CheckGLError();
    glEnableVertexAttribArray(aPosition);
		
    CheckGLError();
  }

  void disable(){
    glUseProgram(0);
    CheckGLError();
    glDisableVertexAttribArray(aPosition);
		
    CheckGLError();
  }
  
  void setUniform_uCamera(const float* const matrix){glUniformMatrix4fv(uCamera, 1, GL_FALSE, matrix);
	CheckGLError();}
	void setUniform_uModelMatrix(const float* const matrix){glUniformMatrix4fv(uModelMatrix, 1, GL_FALSE, matrix);
	CheckGLError();}
	;
  void setAttribute_aPosition(GLint buffer, uint32_t count){glBindBuffer(GL_ARRAY_BUFFER, buffer);glVertexAttribPointer(aPosition,4,GL_FLOAT,GL_FALSE,count,NULL);CheckGLError();}
	;
private:
  
  GLuint compileShader(const char* const shader, GLuint shaderType){
    GLuint vertShader = glCreateShader( shaderType ); 
    CheckGLError();
    glShaderSource( vertShader, 1, &shader, NULL ); 
    CheckGLError();
    glCompileShader( vertShader );
    CheckGLError();
    
    GLint result;
    GLint maxLength = 0;
	  glGetShaderiv(vertShader, GL_INFO_LOG_LENGTH, &maxLength);
    CheckGLError();
	  std::vector<GLchar> errorLog(maxLength);
    CheckGLError();

    glGetShaderiv( vertShader, GL_COMPILE_STATUS, &result ); 
    CheckGLError();
    if( GL_FALSE == result ) { 
      std::cerr << "Vertex shader compilation failed!" << std::endl;
      GLint logLen; 
      glGetShaderiv(vertShader, GL_INFO_LOG_LENGTH, &logLen); 
      CheckGLError();
      if( logLen > 0 ) { 
        std::string log(logLen, ' '); 
        GLsizei written; 
        glGetShaderInfoLog(vertShader, logLen, &written, &errorLog[0]); 
        std::cerr << "Shader log: " << std::endl << &errorLog[0];
      } 
    }
    return vertShader;
  };

  void bind(){
    uCamera = glGetUniformLocation(m_program,"uCamera");
		CheckGLError();
		uModelMatrix = glGetUniformLocation(m_program,"uModelMatrix");
		CheckGLError();
		glBindAttribLocation(m_program,0,"aPosition");
		aPosition=0;
		CheckGLError();
		
  }

  const char * GetGLErrorStr(GLenum err){
    switch (err)
    {
    case GL_NO_ERROR:          return "No error";
    case GL_INVALID_ENUM:      return "Invalid enum";
    case GL_INVALID_VALUE:     return "Invalid value";
    case GL_INVALID_OPERATION: return "Invalid operation";
    case GL_STACK_OVERFLOW:    return "Stack overflow";
    case GL_STACK_UNDERFLOW:   return "Stack underflow";
    case GL_OUT_OF_MEMORY:     return "Out of memory";
    default:                   return "Unknown error";
    }
  }


  GLint uCamera;
	GLint uModelMatrix;
	GLint aPosition;
	
  GLuint m_program;
};


}
}
}
